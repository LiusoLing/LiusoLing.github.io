import{_ as s}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as p,e,a as n,f as t}from"./app-5cCCUltF.js";const c={},o=n("p",null,"在本教程中，我们将详细探索Java语言的静态关键字。",-1),i=n("p",null,"我们将了解如何将静态关键字应用于变量、方法、块和嵌套类，以及它有什么不同。",-1),l=t(`<h2 id="_1-static关键字" tabindex="-1"><a class="header-anchor" href="#_1-static关键字" aria-hidden="true">#</a> 1.static关键字</h2><p>在Java编程语言中，<strong>关键字static意味着特定成员属于类型本身，而不是该类型的实例。</strong></p><p>这意味着我们将只创建一个静态成员的实例，该实例在类的所有实例之间共享。</p><p>我们可以将关键字应用于变量、方法、块和嵌套类。</p><h2 id="_2-静态字段-类变量" tabindex="-1"><a class="header-anchor" href="#_2-静态字段-类变量" aria-hidden="true">#</a> 2.静态字段（类变量）</h2><p>在Java中，<strong>当我们声明一个字段静态时，恰好会创建该字段的单个副本，并在该类的所有实例之间共享。</strong></p><p>我们实例化一个类多少次并不重要。始终只有一个属于它的静态字段副本。这个静态字段的值在同一类的所有对象之间共享。</p><p>从内存的角度来看，<strong>静态变量存储在堆内存中。</strong></p><h3 id="_2-1静态字段示例" tabindex="-1"><a class="header-anchor" href="#_2-1静态字段示例" aria-hidden="true">#</a> 2.1静态字段示例</h3><p>假设我们有一个具有多个属性（实例变量）的Car类。</p><p>每当我们从这个汽车蓝图中实例化新对象时，每个新对象都会有这些实例变量的不同副本。</p><p><br><br><br><br><br><br></p><p>然而，假设我们想要一个变量，它保存实例化Car对象的数量，并在所有实例之间共享，以便他们可以访问它并在初始化时增加它。</p><p>这就是静态变量的用处：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Car</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> engine<span class="token punctuation">;</span>
    
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> numberOfCars<span class="token punctuation">;</span>
    
    <span class="token keyword">public</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> engine<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>engine <span class="token operator">=</span> engine<span class="token punctuation">;</span>
        numberOfCars<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// getters and setters</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，对于我们实例化的该类的每个对象，numberOfCars变量的相同副本都会递增。</p><p>因此，在这种情况下，这些将是真的：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">whenNumberOfCarObjectsInitialized_thenStaticCounterIncreases</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">new</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token string">&quot;Jaguar&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;V8&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">new</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token string">&quot;Bugatti&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;W16&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token class-name">Car</span><span class="token punctuation">.</span>numberOfCars<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-2使用静态字段的原因" tabindex="-1"><a class="header-anchor" href="#_2-2使用静态字段的原因" aria-hidden="true">#</a> 2.2使用静态字段的原因</h3><p>以下是我们何时想使用静态字段的一些原因：</p><ul><li><p>当变量的值独立于对象时</p></li><li><p>当值应该在所有对象之间共享时</p></li></ul><p>由于静态变量属于一个类，我们可以使用类名直接访问它们。因此，<strong>我们不需要任何对象引用。</strong></p><p>我们只能在类级别声明静态变量。</p><p>我们可以<strong>访问静态字段，而无需对象初始化。</strong></p><p>最后，我们可以使用对象引用（如ford.numberOfCars++）访问静态字段。但我们应该避免这种情况，因为很难弄清楚它是实例变量还是类变量。</p><p>相反，我们应该始终<strong>使用类名（Car.numberOfCars++）引用静态变量。</strong></p><h2 id="_3-静态方法-类方法" tabindex="-1"><a class="header-anchor" href="#_3-静态方法-类方法" aria-hidden="true">#</a> 3.静态方法（类方法）</h2><p>与静态字段类似，静态方法也属于类而不是对象。因此，我们可以调用它们，而无需创建它们所在的类的对象。</p><h3 id="_3-1静态方法示例" tabindex="-1"><a class="header-anchor" href="#_3-1静态方法示例" aria-hidden="true">#</a> 3.1静态方法示例</h3><p>我们通常使用静态方法来执行不依赖于实例创建的操作。</p><p>为了在该类的所有实例之间共享代码，我们用静态方法编写它：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setNumberOfCars</span><span class="token punctuation">(</span><span class="token keyword">int</span> numberOfCars<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Car</span><span class="token punctuation">.</span>numberOfCars <span class="token operator">=</span> numberOfCars<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们还通常使用静态方法来创建实用程序或辅助类，以便我们无需创建这些类的新对象即可获得它们。</p><p><br><br><br><br><br><br></p><p>例如，我们可以看看JDK的Collections或Math实用程序类，Apache的StringUtils，或Spring框架的CollectionUtils，并注意到它们的所有实用程序方法都是静态的。</p><h3 id="_3-2使用静态方法的原因" tabindex="-1"><a class="header-anchor" href="#_3-2使用静态方法的原因" aria-hidden="true">#</a> 3.2使用静态方法的原因</h3><p>让我们看看我们想要使用静态方法的几个原因：</p><ul><li><p>访问/操作静态变量和其他不依赖于对象的静态方法。</p></li><li><p>静态方法广泛用于实用程序和辅助类。</p></li></ul><p>Java中的静态方法在编译时解析。由于方法重写是运行时多态性的一部分，因此<strong>静态方法无法重写。</strong></p><p><strong>抽象方法不能是静态的。</strong></p><p>静态方法不能使用<code>this</code>或<code>super</code>关键字。</p><p>以下实例、类方法和变量的组合是有效的：</p><ul><li><p>实例方法可以直接访问实例方法和实例变量</p></li><li><p>实例方法也可以直接访问静态变量和静态方法</p></li><li><p>静态方法可以访问所有静态变量和其他静态方法</p></li><li><p>静态方法不能直接访问实例变量和实例方法。他们需要一些对象引用才能做到这一点。</p></li></ul><h3 id="_3-3在java中调用静态方法中的非静态方法" tabindex="-1"><a class="header-anchor" href="#_3-3在java中调用静态方法中的非静态方法" aria-hidden="true">#</a> 3.3在Java中调用静态方法中的非静态方法</h3><p>为了在静态方法中调用非静态方法，我们必须使用包含非静态方法的类实例。例如，<strong>在main()静态方法中调用非静态方法时，这是一个常见的用例。</strong></p><p>让我们考虑一下我们在本文前面介绍的汽车类的例子，它定义了以下方法：</p><p><br><br><br><br><br><br></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getEngine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> engine<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">getCarsInformation</span><span class="token punctuation">(</span><span class="token class-name">Car</span> car<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> car<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;-&quot;</span> <span class="token operator">+</span> car<span class="token punctuation">.</span><span class="token function">getEngine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>正如我们所看到的，我们在getCarsInformation()静态方法中调用getName()和getEngine()方法，它们是非静态方法。这之所以可能，只是因为我们使用Car对象的实例来访问这些方法。否则，我们会收到此错误消息“非静态方法&#39;getName()&#39;无法从静态上下文引用”。</p><h2 id="_4-静态块" tabindex="-1"><a class="header-anchor" href="#_4-静态块" aria-hidden="true">#</a> 4,静态块</h2><p>我们使用静态块来初始化静态变量。虽然我们可以在声明期间直接初始化静态变量，但在某些情况下，我们需要进行多行处理。在这种情况下，静态块会派上用场。</p><p><strong>如果静态变量在初始化期间需要额外的多陈述逻辑，我们可以使用静态块。</strong></p><h3 id="_4-1静态块示例" tabindex="-1"><a class="header-anchor" href="#_4-1静态块示例" aria-hidden="true">#</a> 4.1静态块示例</h3><p>例如，假设我们想用一些预定义的值初始化一个List对象。</p><p>使用静态块，这变得很容易：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StaticBlockDemo</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> ranks <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        ranks<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;Lieutenant&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ranks<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;Captain&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ranks<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;Major&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        ranks<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;Colonel&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ranks<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;General&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不可能用所有初始值和声明初始化列表对象。因此，这就是我们在这里使用静态块的原因。</p><p>以下是使用静态块的几个原因：</p><ul><li><p>如果静态变量的初始化除了分配之外还需要一些额外的逻辑</p></li><li><p>如果静态变量的初始化容易出错，并且需要异常处理</p></li></ul><p><strong>一个类可以有多个静态块。</strong> 静态字段和静态块以与类中相同的顺序解析和运行。</p><p><br><br><br><br><br><br></p><h2 id="_5-静态类" tabindex="-1"><a class="header-anchor" href="#_5-静态类" aria-hidden="true">#</a> 5.静态类</h2><p>Java允许我们在类中创建一个类。它提供了一种我们只在一个地方使用的元素分组方式。这有助于保持我们的代码更有条理和可读性。</p><p>一般来说，嵌套类架构分为两种类型：</p><ul><li><p>我们声明静态的嵌套类称为<strong>静态嵌套类</strong></p></li><li><p>非静态的嵌套类称为<strong>内部类</strong></p></li></ul><p>两者之间的主要区别在于，内部类可以访问封闭类的所有成员（包括私有成员），而静态嵌套类只能访问外部类的静态成员。</p><p>事实上，<strong>静态嵌套类的行为与任何其他顶级类完全相同，但包含在唯一可以访问它的类中，以提供更好的打包便利。</strong></p><h3 id="_5-1静态类示例" tabindex="-1"><a class="header-anchor" href="#_5-1静态类示例" aria-hidden="true">#</a> 5.1静态类示例</h3><p>创建单项对象最广泛使用的方法是通过静态嵌套类：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span>  <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonHolder</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">SingletonHolder</span><span class="token punctuation">.</span>instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们使用这种方法，因为它不需要任何同步，并且易于学习和实现。</p><p>另一个嵌套静态类示例，其中显示父成员和嵌套成员之间的可见性，反之亦然：</p><p><br><br><br><br><br><br></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Pizza</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">String</span> cookedCount<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">boolean</span> isThinCrust<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">PizzaSalesCounter</span> <span class="token punctuation">{</span>

        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">String</span> orderedCount<span class="token punctuation">;</span>
        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> deliveredCount<span class="token punctuation">;</span>

        <span class="token class-name">PizzaSalesCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Static field of enclosing class is &quot;</span>
              <span class="token operator">+</span> <span class="token class-name">Pizza</span><span class="token punctuation">.</span>cookedCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Non-static field of enclosing class is &quot;</span>
              <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Pizza</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>isThinCrust<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token class-name">Pizza</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Non private static field of static class is &quot;</span>
          <span class="token operator">+</span> <span class="token class-name">PizzaSalesCounter</span><span class="token punctuation">.</span>deliveredCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Private static field of static class is &quot;</span>
          <span class="token operator">+</span> <span class="token class-name">PizzaSalesCounter</span><span class="token punctuation">.</span>orderedCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token keyword">new</span> <span class="token class-name">Pizza<span class="token punctuation">.</span>PizzaSalesCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们运行主方法时，结果是：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Static</span> field of enclosing <span class="token keyword">class</span> is <span class="token keyword">null</span>
<span class="token class-name">Non</span> <span class="token keyword">private</span> <span class="token keyword">static</span> field of <span class="token keyword">static</span> <span class="token keyword">class</span> is <span class="token keyword">null</span>
<span class="token class-name">Private</span> <span class="token keyword">static</span> field of <span class="token keyword">static</span> <span class="token keyword">class</span> is <span class="token keyword">null</span>
<span class="token class-name">Non</span><span class="token operator">-</span><span class="token keyword">static</span> field of enclosing <span class="token keyword">class</span> is <span class="token boolean">false</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>让我们看看在代码中使用静态内部类的几个原因：</p><ul><li><p>仅在一个地方使用的分组类增加了封装</p></li><li><p>我们让代码更接近唯一会使用它的地方。这增加了可读性，代码也更易于维护。</p></li><li><p>如果嵌套类不需要对其封闭的类实例成员进行任何访问，则最好将其声明为静态。这样，它就不会与外部类耦合，因此更理想，因为它们不需要任何堆或堆栈内存。</p></li></ul><p>基本上，<strong>静态嵌套类无法访问封闭外类的任何实例成员。它只能通过对象的引用访问它们。</strong></p><p>静态嵌套类可以访问封闭类的所有静态成员，包括私有成员。</p><p><strong>Java编程规范不允许我们将顶级类声明为静态。</strong> 只有类中的类（嵌套类）可以作为静态的。</p>`,81);function u(r,d){return a(),p("div",null,[o,i,e(" more "),l])}const m=s(c,[["render",u],["__file","14 java static keyword.html.vue"]]);export{m as default};
