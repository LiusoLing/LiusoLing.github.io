import{_ as s}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as n,c as a,f as p}from"./app-hJ4_2O4c.js";const e={},o=p(`<p>窗口函数对一组与当前行以某种方式相关的表行执行计算。</p><p>这与可以使用 aggregate 函数完成的计算类型相当。</p><p>但是，窗口函数不会像非窗口聚合调用那样导致行分组为单个输出行。</p><p>相反，这些行保留其单独的身份。在后台，window 函数能够访问的不仅仅是查询结果的当前行。</p><p>以下示例显示了如何将每个员工的薪水与其部门的平均薪水进行比较：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> depname<span class="token punctuation">,</span> empno<span class="token punctuation">,</span> salary<span class="token punctuation">,</span> <span class="token function">avg</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> depname<span class="token punctuation">)</span> <span class="token keyword">FROM</span> empsalary<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>窗口函数调用始终在窗口函数的名称和参数后面直接包含一个 OVER 子句。这就是它在语法上与普通函数或非窗口聚合的区别。</p><p><strong>OVER 子句准确确定如何拆分查询的行以供 window 函数处理。OVER 中的 PARTITION BY 子句将行划分为多个组或分区，这些组或分区共享 PARTITION BY 表达式的相同值。</strong></p><p>对于每一行，窗口函数是在与当前行属于同一分区的行之间计算的。</p><p><br><br><br></p><p>您还可以使用 OVER 中的 ORDER BY 控制窗口函数处理行的顺序。（窗口 ORDER BY 甚至不必匹配行的输出顺序.）下面是一个示例：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> depname<span class="token punctuation">,</span> empno<span class="token punctuation">,</span> salary<span class="token punctuation">,</span>
       rank<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> depname <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> salary <span class="token keyword">DESC</span><span class="token punctuation">)</span>
<span class="token keyword">FROM</span> empsalary<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上所示，rank 函数使用 ORDER BY 子句定义的顺序为当前行分区中的每个不同 ORDER BY 值生成数字排名。</p><p>rank 不需要显式参数，因为它的行为完全由 OVER 子句决定。</p><p>窗口函数考虑的行是由查询的 FROM 子句生成的“虚拟表”的行，一个查询可以包含多个窗口函数，这些窗口函数使用不同的 OVER 子句以不同的方式对数据进行切片，但它们都作用于此虚拟表定义的同一行集合。</p><p>如果 over 子句后没有提供切片的数据范围，默认以整表作为切片数据范围：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> salary<span class="token punctuation">,</span> <span class="token function">sum</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> empsalary<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>但是如果我们添加 ORDER BY 子句，我们会得到非常不同的结果：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> salary<span class="token punctuation">,</span> <span class="token function">sum</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> salary<span class="token punctuation">)</span> <span class="token keyword">FROM</span> empsalary<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>由于缺少 PARTITION BY 是整个表; 换句话说，每个 sum 都接管了整个表。</p><p>又因为提供了 ORDER BY，所以 sum 聚合的是 整个表分区开始到结果行的当前行的所有行。</p><p>如果在执行窗口计算后需要筛选或分组行，则可以使用子选择。例如：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> depname<span class="token punctuation">,</span> empno<span class="token punctuation">,</span> salary<span class="token punctuation">,</span> enroll_date
<span class="token keyword">FROM</span>
  <span class="token punctuation">(</span><span class="token keyword">SELECT</span> depname<span class="token punctuation">,</span> empno<span class="token punctuation">,</span> salary<span class="token punctuation">,</span> enroll_date<span class="token punctuation">,</span>
          rank<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> depname <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> salary <span class="token keyword">DESC</span><span class="token punctuation">,</span> empno<span class="token punctuation">)</span> <span class="token keyword">AS</span> pos
     <span class="token keyword">FROM</span> empsalary
  <span class="token punctuation">)</span> <span class="token keyword">AS</span> ss
<span class="token keyword">WHERE</span> pos <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><br><br><br></p><p>当查询涉及多个窗口函数时，可以使用单独的 OVER 子句写出每个窗口函数，但如果多个函数需要相同的窗口行为，则这是重复且容易出错的。</p><p>相反，每个窗口行为都可以在 WINDOW 子句中命名，然后在 OVER 中引用。例如：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token function">sum</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token keyword">OVER</span> w<span class="token punctuation">,</span> <span class="token function">avg</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token keyword">OVER</span> w
  <span class="token keyword">FROM</span> empsalary
  WINDOW w <span class="token keyword">AS</span> <span class="token punctuation">(</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> depname <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> salary <span class="token keyword">DESC</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,27),t=[o];function l(c,i){return n(),a("div",null,t)}const k=s(e,[["render",l],["__file","3.5 Window Functions.html.vue"]]);export{k as default};
